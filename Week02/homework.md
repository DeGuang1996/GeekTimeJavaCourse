## Q1:

### JVM内存模型:

1. 堆: JVM内存管理最大的一块, 被线程共享, 目的是存放对象的实例, 几乎所有的对象实例都会放在这里. 当堆没有可用空间时, 会抛出OOM异常. 根据对象的存活周期不同, JVM把对象进行分代管理, 由垃圾回收器进行垃圾的回收管理. 
2. 虚拟机栈: 又称方法栈, 线程私有的, 线程执行方法是会创建一个栈帧, 用来存储局部变量表/操作栈/动态链接/方法出口等信息. 调用方法时执行入栈, 方法返回时执行出栈.
3. 本地方法栈: 与虚拟机栈类似, 也是用来保存执行方法的信息. 执行Java方法是使用虚拟机栈, 执行Native方法时使用本地方法栈.
4. 方法区: 又称非堆区, 用于存储已被虚拟机加载的类信息, 常量, 静态变量, 即时编译器优化后的代码等数据. 1.7的永久代和1.8的元空间都是方法区的一种实现.
5. 运行时常量池: 方法区的一部分, 用于存储编译生成的各种常量.
6. 直接内存: 即服务器真实的物理内存.

### 为什么堆内存要分年轻代和老年代:

有的对象生命周期比较长, 有的比较短, 分开放在不同的地方可以提高管理效率(GC效率).

## Q2:

### 描述一个 Java 对象的生命周期:

在对象创建阶段,系统要通过下面的步骤,完成对象的创建过程：

1.  为对象分配存储空间.
2. 开始构造对象.
3. 递归调用其父类的构造方法.
4. 进行对象实例初始化与变量初始化.
5. 执行构造方法体.

对象的销毁:
对象处于不可达阶段是指该对象不再被任何强引用所持有, 该对象仍可能被JVM等系统下的某些已装载的静态变量或线程或JNI等强引用持有着, 这些特殊的强引用被称为”GC root”. 存在着这些GC root会导致对象的内存泄露情况, 无法被回收.
当垃圾回收器发现该对象已经处于"不可达阶段"而且垃圾回收器已经对该对象的内存空间又一次分配做好准备时, 则对象进入了“收集阶段”.
当没有任何引用指向Class对象时就会被卸载, 结束类的生命周期.

### 对象的 2 种访问方式是什么:

1. 使用句柄: Java堆划分一块内存作为句柄池, 对象reference中存储就是对象的句柄地址.
2. 使用直接指针: 对象reference中存储就是在堆中分配的对象实例数据的地址.

### 为什么需要内存担保:

1. 新建的对象(除了大数据对象)会首先分配在Eden区, 如果Eden区空间不够时, 就会发生一次Minor GC.
2. 当新生代的对象进入老年代时, 如果老年代的空间不够时, 就会发生一次Full GC, 大对象一般会直接进入老年代, 为了防止在Eden/Survivor区中copy带来的性能消耗.
3. 每次发生Minor GC时, Java虚拟机会检测老年代的剩余空间是否大于新生代的总空间, 如果大于, 则直接发生MinorGC, 而且操作是安全的. 如果小于, 那么此时就引入了内存担保.

老年代存当了担保的角色.

## Q3:

### 垃圾收集算法

#### 标记 - 清除

将存活的对象进行标记, 然后清理掉未被标记的对象.
不足:
标记和清除过程效率都不高;
会产生大量不连续的内存碎片, 导致无法给大对象分配内存.

#### 标记 - 整理

让所有存活的对象都向一端移动, 然后直接清理掉端边界以外的内存.

#### 复制

将内存划分为大小相等的两块, 每次只使用其中一块, 当这一块内存用完了就将还存活的对象复制到另一块上面, 然后再把使用过的内存空间进行一次清理.
主要不足是只使用了内存的一半.

#### 分代收集

现在的商业虚拟机采用分代收集算法, 它根据对象存活周期将内存划分为几块, 不同块采用适当的收集算法.

### 垃圾收集器
#### Serial 收集器

Serial 翻译为串行, 也就是说它以串行的方式执行. 它是单线程的收集器, 只会使用一个线程进行垃圾收集工作.

#### ParNew 收集器

它是 Serial 收集器的多线程版本. 是 Server 模式下的虚拟机首选新生代收集器, 除了性能原因外, 主要是因为除了 Serial 收集器, 只有它能与 CMS 收集器配合工作.

#### Parallel Scavenge 收集器

与 ParNew 一样是多线程收集器. 其它收集器关注点是尽可能缩短垃圾收集时用户线程的停顿时间,而它的目标是达到一个可控制的吞吐量,它被称为“吞吐量优先”收集器.这里的吞吐量指 CPU 用于运行用户代码的时间占总时间的比值.

#### Serial Old 收集器

是 Serial 收集器的老年代版本,也是给 Client 模式下的虚拟机使用.

#### Parallel Old 收集器

是 Parallel Scavenge 收集器的老年代版本.在注重吞吐量以及 CPU 资源敏感的场合,都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器.

#### CMS 收集器

CMS(Concurrent Mark Sweep),Mark Sweep 指的是标记 - 清除算法. 分为以下四个流程: 

1. 初始标记: 仅仅只是标记一下 GC Roots 能直接关联到的对象,速度很快,需要停顿. 
2. 并发标记: 进行 GC Roots Tracing 的过程,它在整个回收过程中耗时最长,不需要停顿. 
3. 重新标记: 为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录,需要停顿. 
4. 并发清除: 不需要停顿.

#### G1 收集器

G1(Garbage-First),它是一款面向服务端应用的垃圾收集器,在多 CPU 和大内存的场景下有很好的性能.HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器. 堆被分为新生代和老年代,其它收集器进行收集的范围都是整个新生代或者老年代,而 G1 可以直接对新生代和老年代一起回收.G1 把堆划分成多个大小相等的独立区域(Region),新生代和老年代不再物理隔离.

通过引入 Region 的概念,从而将原来的一整块内存空间划分成多个的小空间,使得每个小空间可以单独进行垃圾回收.这种划分方法带来了很大的灵活性,使得可预测的停顿时间模型成为可能.通过记录每个 Region 垃圾回收时间以及回收所获得的空间(这两个值是通过过去回收的经验获得),并维护一个优先列表,每次根据允许的收集时间,优先回收价值最大的 Region. 每个 Region 都有一个 Remembered Set,用来记录该 Region 对象的引用对象所在的 Region.通过使用 Remembered Set,在做可达性分析的时候就可以避免全堆扫描.
